# -*- coding: utf-8 -*-
"""Recognition_lab4.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GX3p8co6OaIYFR38z-vEbkUcWUyA-AKJ

# Розпізнавання об'єктів на зображеннях з набору даних CIFAR-10
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from keras.datasets import cifar10
from keras.models import Sequential
from keras.layers import Dense, Flatten
from keras.layers import Dropout
from keras.layers.convolutional import Conv2D, MaxPooling2D
from keras.optimizers import Adam
from keras.utils import np_utils
from keras import regularizers
import matplotlib.pyplot as plt

# %matplotlib inline

# Розмір міні-вибірки
batch_size = 128
# Кількість класів зображень
nb_classes = 10
# Кількість епох для навчання
nb_epoch = 30
# Розмір зображеннь
img_rows, img_cols = 32, 32
# Кількість каналів в зображенні 
img_channels = 3
# Назви класівз набору даних  CIFAR-10
classes = ['літак', 'автомобіль', 'птиця', 'кіт', 'олень', 'собака', 'жаба', 'кінь', 'корабель', 'вантажівка']

"""## Підготовка даних

**Завантажуємо дані**
"""

(X_train, y_train), (X_test, y_test) = cifar10.load_data()

"""**Перагляд прикладів даних**"""

n = 1
plt.imshow(X_train[n])
plt.show()
print("Номер класу:", y_train[n])
print("Тип об'єкту:", classes[y_train[n][0]])

"""**Нормалізуємо  дані**"""

X_train = X_train.astype('float32')
X_test = X_test.astype('float32')
X_train /= 255
X_test /= 255

"""**Перетворюємо вірні відповіді в формат one hot encoding**"""

Y_train = np_utils.to_categorical(y_train, nb_classes)
Y_test = np_utils.to_categorical(y_test, nb_classes)

"""## Створюємо нейронну мережу"""

# Створюємо послідовну модель
model = Sequential()

# First Conv layer
model.add(Conv2D(filters=128, kernel_size=(3,3), activation='relu', padding='same', kernel_regularizer=regularizers.l2(1e-4), input_shape=(32,32,3)))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.3))

# Second Conv layer
model.add(Conv2D(filters=256, kernel_size=(3,3), activation='relu', padding='same', kernel_regularizer=regularizers.l2(1e-4)))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.3))

# Third, fourth, fifth convolution layer
model.add(Conv2D(filters=512, kernel_size=(3,3), activation='relu', padding='same', kernel_regularizer=regularizers.l2(1e-4)))
model.add(Conv2D(filters=512, kernel_size=(3,3), activation='relu', padding='same', kernel_regularizer=regularizers.l2(1e-4)))
model.add(Conv2D(filters=256, kernel_size=(3,3), activation='relu', padding='same', kernel_regularizer=regularizers.l2(1e-4)))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.3))

# Fully Connected layers
model.add(Flatten())

model.add(Dense(512, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))

model.add(Dense(10, activation='softmax'))
# # Перший згортковий шар
# model.add(Conv2D(64, (3, 3), padding='same',
#                  input_shape=(32, 32, 3), activation='relu'))
#
# # Другий згортковий шар
# model.add(Conv2D(128, (3, 3), activation='relu', padding='same'))
# model.add(MaxPooling2D(pool_size=(2, 2)))
# model.add(Dropout(0.25))
#
# # 3,4,5 згорткові шари
# model.add(Conv2D(256, (3, 3), padding='same', activation='relu'))
# model.add(Conv2D(256, (3, 3), padding='same', activation='relu'))
# model.add(Conv2D(128, (3, 3), padding='same', activation='relu'))
#
# model.add(MaxPooling2D(pool_size=(2, 2)))
# model.add(Dropout(0.25))
#
# # Шар перетворення даних з 2D представлення в пласке
# model.add(Flatten())
# # Повнозв'язаний шар для класифікації
# model.add(Dense(256, activation='relu'))
# model.add(Dense(128, activation='relu'))
# model.add(Dense(64, activation='relu'))
# model.add(Dropout(0.5))
# # Вихідний Повнозв'язаний шар
# model.add(Dense(nb_classes, activation='softmax'))

"""**Друкуємо інформацію щодо мережі**"""

print(model.summary())

"""**Компілюємо модель**"""

model.compile(loss='categorical_crossentropy',
              optimizer=Adam(lr=0.0003, decay=1e-6),
              metrics=['accuracy'])

"""## Навчаємо нейрону мережу"""

history = model.fit(X_train, Y_train,
                    batch_size=batch_size,
                    epochs=nb_epoch,
                    validation_split=0.1,
                    shuffle=True,
                    verbose=2)

"""## Оцінюємо якість  навчання мережі"""

# Оцінюємо якість навчання моделі на тестових даних
scores = model.evaluate(X_test, Y_test, verbose=0)
print("Точність роботи на тестових даних: %.2f%%" % (scores[1] * 100))

history_dict = history.history
acc_values = history_dict['accuracy']
val_acc_values = history_dict['val_accuracy']
epochs = range(1, len(acc_values) + 1)
plt.plot(epochs, acc_values, 'bo', label='Training acc')
plt.plot(epochs, val_acc_values, 'b', label='Validation acc')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

"""## Зберігаємо навчену нейрону мережу"""

model_json = model.to_json()
json_file = open("cifar10_model.json", "w")
json_file.write(model_json)
json_file.close()
model.save_weights("cifar10_model1.h5")
